# 题解

## 1.

### 在 Python 3 中，下列程序结果为：

```python
dict1 = {'one': 1, 'two': 2, 'three': 3}
dict2 = {'one': 4, 'tmp': 5}
dict1.update(dict2)
print(dict1)
```

答案：`{'one': 4, 'two': 2, 'three': 3, 'tmp': 5}` 

> 解析：`dict.update(dict2)`把字典`dict2`的键/值对更新到`dict`里

****

## 2.

### What gets printed?:

```python
kvps = { '1' : 1, '2' : 2 }
theCopy = kvps.copy()
kvps['1'] = 5
sum = kvps['1'] + theCopy['1']
print sum
```

答案：`6`

> 解析：
>
> `kvps.copy()`相当于复制一份，原来的改变不影响复制后的，理解为独立的
>
> ```python
> import copy
> theqian = copy.copy(kvps)
> ```
>
> 这个是真正的浅拷贝，`kvps`内部对象变，`theqian`也会跟着变，`kvps`指向其它对象，`theqian`不变。
>
> 例如：
>
> ```python
> >>> import copy 
> >>> origin = [1, 2, [3, 4]] #origin 里边有三个元素：1， 2，[3, 4]
> >>> cop1 = copy.copy(origin)
> >>> origin[2][0] = "hey!"
> >>> origin 
> [1, 2, ['hey!', 4]] 
> >>> cop1
> [1, 2, ['hey!', 4]]
> ```
>
> `theshen = copy.deepcopy(kvps)`这个是真正的深拷贝，`kvps`怎么变，`theshen`不变。
>
> 总结：
>
> `a = object.copy()` 等价于 `b = copy.deepcopy(object)`,`a`和`b`一样
>
> `copy.copy(object)`是浅拷贝，相当于变量引用,等同于下面代码。
>
> ```python
> a = [1,2,3]
> b = a
> a = [4,5,6]
> >>>b
> [1,2,3]
> c = b
> b[0] = 20
> >>>c
> [20,2,3]
> ```

****

## 3.

### 对于下面的 Python 3 函数，如果输入的参数n非常大，函数的返回值会趋近于以下哪一个值（选项中的值用 Python 表达式来表示）：

```python
import random 
def foo(n):
    random.seed()
    c1 = 0
    c2 = 0
    for i in range(n):
		x = random.random()
		y = random.random()
		r1 = x * x + y * y
		r2 = (1 - x) * (1 - x) + (1 - y) * (1 - y)
		if r1 <= 1 and r2 <= 1:
			c1 += 1
		else:
			c2 += 1
	return c1 / c2
```

答案：`(math.pi - 2) / (4 - math.pi)`

> 解析：你这点数学积分都不会？？

****

## 4.

### 在 Python 3 中，关于字符串的运算结果为：

```python
strs = 'abcd'
print(strs.center(10, '*'))
```

答案：`'***abcd***'`

> 解析：在 Python 3 中，`center() `返回一个原字符串居中,并使用空格填充至长度 `width `的新字符串。默认填充字符为空格。题目中填充长度 `width=10`, 填充字符为`‘*’`，最终的结果为 `'***abcd***'`

****

## 5.

### 假设可以不考虑计算机运行资源（如内存）的限制，以下  Python 3  代码的预期运行结果是：

```python
import math
def sieve(size):
    sieve= [True] * size
    sieve[0] = False
    sieve[1] = False
    for i in range(2, int(math.sqrt(size)) + 1):
        k= i * 2
        while k < size:
           sieve[k] = False
           k += i
    return sum(1 for x in sieve if x)
print(sieve(10000000000))
```

答案：`455052511`

> 解析：怎么会有这种题，求100亿以内的质数个数，我求的出来我还会在这做题？？

****

## 6.

### 列表`lis=[1,2,3,4,5,6]`，其切片`lis[-1:1:-1]`结果为：

答案：`[6,5,4,3]`

> 解析：切片`[start:stop:step]`，当`step`为负值时，表示从右往左，索引`start=-1`的元素是`6`，索引`stop=1`的元素是`2`，但是不会取到该索引，因此从右往左，间隔为`1`取到的结果就是`[6,5,4,3]`。

****

## 7.

### 在 Python 3 中，字符串的变换结果为：

```python
strs = 'I like python and java'
print(strs.replace('I', 'Your'))
print(strs.replace('a', '*', 2))
```

答案：`'Your like python and java'，'I like python *nd j*va'`

> 解析：
>
> 在 Python 3 中，`string.replace(str1, str2, num=string.count(str1))`，把 `string` 中的 `str1 `替换成 `str2`,如果 `num `指定，则替换不超过 `num `次。
>
> 因此 `strs.replace('I', 'Your')` 的结果为：`'Your like python and java'`；`strs.replace('a', '*', 2)`的结果为：`'I like python *nd j*va'`，只会替换字符串中的两个 `‘a’` 字符。

****

## 8.

### 以下代码运行结果为：

```python
func = lambda x:x%2
result = filter(func, [1, 2, 3, 4, 5])
print(list(result))
```

答案：`[1,3,5]`

> 解析：`filter(function, iterable)`
>
> `filter`函数是python中的高阶函数, 第一个参数是一个筛选函数, 第二个参数是一个可迭代对象, 返回的是一个生成器类型, 可以通过`next`获取值. 这里大致讲述下原理, `filter()`把传入的`function`依次作用于`iterable`的每个元素, 满足条件的返回`true`, 不满足条件的返回`false`, 通过`true`还是`false`决定将该元素丢弃还是保留。
>
> 所以对`2`和`4`取余为`0`舍弃`1、3、5`取余为`1`为真保留。

****

## 9.

### 在 Python 3 中，下列程序结果为：

```python
dicts = {'a': 1, 'b': 2, 'c': 3}
print(dicts.pop())
```

答案：`报错`

> 解析：`dict`的`pop()`是删除指定key的键和值，如果没有指定，则返回default，就会报错；而`list`的`pop()`是删除最后一个值并返回。
>
> > 描述
> >
> > Python 字典 `pop() `方法删除字典给定键 key 及对应的值，返回值为被删除的值。key 值必须给出。 否则，返回 default 值。
>
> >语法
> >
> >`pop()`方法语法：
> >
> >```python
> >pop(key[,default])
> >```
>
> > 参数
> >
> > - key：要删除的键值
> >
> > - default：如果没有 key，返回 default 值

****

## 10.

### 下列程序打印结果为：

```python
import re 
str1 = "Python's features" 
str2 = re.match( r'(.*)on(.*?) .*', str1, re.M|re.I)
print str2.group(1)
```

答案：`Pyth`

> 解析：
>
> ![image-20221021115110042](https://raw.githubusercontent.com/12cjn/lizituchuang/main/img/202210211151611.png)
>
> ![image-20221021115148091](https://raw.githubusercontent.com/12cjn/lizituchuang/main/img/202210211151396.png)
>
> 参考：[链接1](https://blog.csdn.net/liyahui_3163/article/details/78434157) [链接2](https://www.cnblogs.com/feifeifeisir/p/10627474.html)

****

## 11.

### 在 Python 3 中，程序运行结果为：

```python
tmp = dict.fromkeys(['a', 'b'], 4)
print(tmp)
```

答案：`{'a':4, 'b':4}`

> 解析：Python 3 字典`fromkeys(seq, value)`函数用于创建一个新字典，以序列`seq`中元素做字典的键，`value`为字典所有键对应的初始值。该方法返回一个新字典。

****

## 12.

### 在 Python 3 运行环境下，执行以下选项中的代码，其输出结果不为[2,4,6,8,10]的是：

> `A`
>
> ```python
> a = [1,2,3,4,5,6,7,8,9,10]
> print(a[1::2])
> ```
>
> `B`
>
> ```python
> a = [1,2,3,4,5,6,7,8,9,10]
> lis = []
> for i in a:
>     if i % 2 == 0:
>         lis.append(i)
> print(lis)
> ```
>
> `C`
>
> ```python
> a = [1,2,3,4,5,6,7,8,9,10]
> print(list(filter(lambda x:x % 2 ==0,a)))
> ```
>
> `D`
>
> ```python
> a = [1,2,3,4,5,6,7,8,9,10]
> def is_odd(n):
>     return n % 2 == 0
> print(list(filter(is_odd(),a)))
> ```

答案：`D`

> 解析：D选项会抛出一个缺少位置参数的异常，实际上这里调用的是函数本身，是整个函数体，不需要等待函数执行完成，所以调用时不需要加小括号，正确的调用方式为`print(list(filter(is_odd,a)))`

****

## 13.

### 执行下列程序，输出结果为：

```python
def fun(a,*,b):
    print(b)
fun(1,2,3,4)
```

答案：`报错`

> 解析：当函数的的形参单独为`*`时，它并不属于未匹配的位置参数，而是表示后面的参数必须使用关键字参数进行匹配，所以这里会抛出异常。

****

## 14.

### 在 Python 3 中，关于字符串的判断正确的是：

```python
str1 = ''
str2 = ' '
if not str1:
    print(1)
elif not str2:
    print(2)
else:
    print(0)
```

答案：`1`

> 解析：在`Python3`中，逻辑运算符`not`表示非，字符串`str1`表示空字符，`str2`虽然也表示空格字符，其长度是为`1`，因此在题目中会判断`str1`为空打印`1`

****

## 15.

### 在 Python 3 中，关于程序运行结果说法正确的是：

```python
dicts = {}
dicts[([1, 2])] = 'abc'
print(dicts)
```

答案：`报错`

> 解析：在`Python3`中，只有当元组内的所有元素都为不可变类型的时候，才能成为字典的`key`，因此程序运行过程中会报错：`TypeError: unhashable type: 'list'`

****
